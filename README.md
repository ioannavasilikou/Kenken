# Kenken
Το __Kenken__ είναι ένα δημοφιλές _αριθμητικό πάζλ λογικής_, το οποίο εφευρέθηκε από τον Γιαπωνέζο δάσκαλο μαθηματικών Tesuya Miyamoto, ο οποίος εφαρμόζει την πρακτική _«η τέχνη της διδασκαλίας χωρίς διδασκαλία»_. Το Kenken είναι ένα πλέγμα κελιών, __n×n__, το οποίο μπορεί να συμπληρωθεί με αριθμούς από το 1 έως το n. Οι διαστάσεις του πλέγματος κυμαίνονται από 3×3 έως 9×9.
Κύριο χαρακτηριστικό του Κenken είναι ότι αποτελείται από ομάδες κελιών, τις κλίκες, οι οποίες συνοδεύονται από έναν αριθμό και μια μαθηματική πράξη (πρόσθεση, αφαίρεση, πολλαπλασιασμός, διαίρεση). Οι αριθμοί που θα εισαχθούν στα κελιά της ίδιας κλίκας θα πρέπει να παράγουν τον αριθμό στόχο χρησιμοποιώντας τη μαθηματική πράξη που υποδηλώνεται για την ομάδα αυτή. Επιπρόσθετα, κάθε αριθμός μπορεί να εμφανιστεί μόνο μία φορά σε κάθε γραμμή ή στήλη του πλέγματος. Μέσα σε μια κλίκα μπορεί να επαναληφθεί κάποιος αριθμός δεδομένου ότι δε βρίσκεται στην ίδια γραμμή ή στήλη.

Ο κώδικας για τους αλγορίθμους _backtracking_ ανήκουν στο: https://github.com/aimacode/aima-python/blob/master/csp.py

__Ορισμός προβλήματος ικανοποίησης περιορισμών__:
΄Εστω ένας πίνακας nxn:
_Μεταβλητές_:
κάθε κελί του πίνακα αποτελεί και μία μεταβλητή του προβλήματος
∀i, j ∈ [1, n]− > (i, j) είναι η μεταβλητές
Στο πρόβλημα, οι μεταβλητές αποθηκεύονται σε μία λίστα.
πχ. [(1, 1), (1, 2), (1, 3), (2, 1), ...]

_Πεδία_:
κάθε μεταβλητή έχει ως πεδίο τις τιμές από 0 μέχρι n
∀i, j ∈ [1, n] : Dij = {1, ..., n}
Στο πρόβλημα, τα πεδία αποθηκεύονται σε ένα λεξικό, στο οποίο για κάθε μεταβλητή υπάρχει ένα tuple με τις τιμές που μπορεί να πάρει, οι οποίες είναι από 1 μέχρι τις διαστάσεις του πινακα.
πχ. {(1, 1) : (1, 2, 3), (1, 2) : (1, 2, 3), ...}

_Περιορισμοί_:
C1 : {∀(i, j), ∀k ∈ [1, n] : (i, j) ̸= (k, j)}
(η τιμή της κάθε μεταβλητής θα πρέπει να είναι διαφορετική από της τιμές των μεταβλητών της ίδιας γραμμής)
C2 : {∀(i, j), ∀k ∈ [1, n] : (i, j) ̸= (i, k)}
(η τιμή της κάθε μεταβλητής θα πρέπει να είναι διαφορετική από τις τιμές των μεταβλητών της ίδιας στήλης)
C3 : {η πράξη με τις τιμές των μεταβλητών της κλίκας θα πρέπει να δίνει το ζητούμενο αποτέλεσμα}

Στην υλοποίηση του προβλήματος, η συνάρτηση _init_ της κλάσης _Kenken_ αρχικοποιεί τις μεταβλητές και τα πεδία όπως αναφέρθηκε πιό πάνω επίσης αρχικοποιούνται οι κλίκες οι οποίες αναπαρίστανται ως ένα λεξικό, όπου σε κάθε μεταβλητή αντιστοιχεί ένα tuple στο οποίο το στοιχείο 0 είναι η πράξη, το στοιχείο 1 είναι το αποτέλεσμα της πράξης και το 3 ένα tuple στο οποίο είναι αποθηκευμένες οι μεταβλητές της κλίκας (και η μεταβλητή που εξετάζουμε).
πχ. {(1, 1) : (΄+΄, 3, (1, 1), (1, 2) ), ...}

Επίσης, οι γείτονες αναπαρίστανται με ένα λεξικό στο οποίο για κάθε μεταβλητή υπάρχει ένα tuple που περιέχει ένα tuple με τις μεταβλητές της γραμμής και της στήλης και ένα με τις μεταβλητές της κλίκας.
πχ. {(1, 2) : ( ( (1, 1), (1, 3), (2, 2), (3, 2) ), (1, 1), (1, 2), (2, 1) )}

Στην ίδια κλάση υπάρχει μία συνάρτηση _print puzzle_ η οποία τυπώει τη λύση του πάζλ.

Ακόμα, υπάρχει η συνάρτηση _kenken solve_ η οποία αρχικοπιεί την κλάση _CSP_ και καλεί τις κατάλληλες συναρτήσεις για την επίλυση του προβλήματος.

Στην _constraint function_ ελέγχει τα Α και Β αν είναι η ίδια μεταβλητή και επιστρέφει False, ελέγχει αν η Α είναι γείτονας της Β (ισχύει και το αντίστροφο), δηλαδή αν είναι στην ίδια γραμμή ή στήλη και αν είναι και έχουν την ίδια τιμή, επιστρέφει False. ΄Επειτα αρχίζει και ελέγχει στην κλίκα της κάθε μεταβλητής την πράξη που πρέπει να γίνει.

>_(α) αν είναι απλή ανάθεση τιμής_:
επιστρέφει True / False ανάλογα με το αν είναι η σωστή τιμή. ΄Αν η μεταβλητή ανήκει στην κλίκα της άλλης (γίνεται έλεγχος μόνο για τη μία μεταβλητή, μπορεί να παραλειφθεί ο έλεγχος για την αλλή, καθώς αν η μία ανήκει στην κλίκα της άλλης, τότε συμβαίνει και το αντίστροφο).

>_(β) αν είναι πρόσθεση_:
αν το άθροισμα των δύο μεταβλητών ξεπερνά το επιθυμητό, επιστρέφει False, αλλιώς για κάθε μεταβλητή της κλίκας αθροίζει τις προσωρινές τιμές που έχουν πάρει είτε από προηγούμενη ανάθεση, είτε τις νέες τιμές και ελέγχει το άθροισμα, αν είναι μεγαλύτερο επιστρέφει False, αν είναι ίσο και έχει γίνει ανάθεση τιμής σε όλες τις μεταβλητές της κλίκας επιστρέφει True, αν είναι μικρότερο και δεν έχει γίνει ανάθεση σε όλες τις μεταβλητές τις κλίκας επιστρέφει True, σε κάθε άλλη περίπτωση False.

>_(γ) αν είναι γινόμενο_:
αν το γινόμενο των δύο μεταβλητών ξεπερνά το επιθυμητό, επιστρέφει False , αλλιώς για κάθε μεταβλητή της κλίκας πολλαπλασιάζει τις προσωρινές τιμές που έχουν πάρει είτε από προηγούμενη ανάθεση, είτε τις νέες τιμές και ελέγχει το γινόμενο, αν είναι μεγαλύτερο επιστρέφει False, αν είναι ίσο και έχει γίνει ανάθεση τιμής σε όλες τις μεταβλητές της κλίκας επιστρέφει True, αν είναι μικρότερο και δεν έχει γίνει ανάθεση σε όλες τις μεταβλητές τις κλίκας επιστρέφει True, σε κάθε άλλη περίπτωση False.
>_(δ) αν είναι αφαίρεση_:
αν η απόλυτη τιμή της αφαίρεσης των δύο αριθμών είναι μικρότερη ή μεγαλύτερη από την επιθυμητή επιστρέφει False.
>_(ε) αν είναι διαίρεση_:
αν ο μεγαλύτερος αριθμός διά τον μικρότερο αριθμό από τους δύο, είναι ίσο με το επιθυμητό αποτέλεσμα επιστρέφει True, αλλιώς False.

Παρακάτω παρουσιάζεται ο πίνακας με τις μετρήσεις των δύο αλγορίθμων που χρησιμοποιήθηκαν για κάποια προβλήματα, ως προς τον χρόνο που χρειάζονται για την επίλυση, τον αριθμό των αναθέσεων που γίνονται στις μεταβλητές και τον αριθμό των ελέγχων για τους περιορισμόυς:
https://github.com/ioannavasilikou/Kenken/blob/main/image.png
